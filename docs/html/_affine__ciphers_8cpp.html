<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: affine_ciphers/Affine_ciphers.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_747db3f0643bdd2a04a987f13f470f6b.html">affine_ciphers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Affine_ciphers.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_affine__ciphers_8hpp_source.html">Affine_ciphers.hpp</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a416bb0c2856bddb53c89915f9ae5542c" id="r_a416bb0c2856bddb53c89915f9ae5542c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a416bb0c2856bddb53c89915f9ae5542c">mutual_simple</a> (int a, int b)</td></tr>
<tr class="separator:a416bb0c2856bddb53c89915f9ae5542c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1a3664018850dab00f52655fe3ab0" id="r_a3bb1a3664018850dab00f52655fe3ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a3bb1a3664018850dab00f52655fe3ab0">replacement_cipher_data_is_valid</a> (const std::string &amp;text, const std::string &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:a3bb1a3664018850dab00f52655fe3ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae971d1807a2010eabdb75b3bd393b3e7" id="r_ae971d1807a2010eabdb75b3bd393b3e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#ae971d1807a2010eabdb75b3bd393b3e7">affine_cipher_data_is_valid</a> (const std::string &amp;text, const std::vector&lt; int &gt; &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:ae971d1807a2010eabdb75b3bd393b3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38190e6d22fed7da3c1eb5c15c1b70ce" id="r_a38190e6d22fed7da3c1eb5c15c1b70ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a38190e6d22fed7da3c1eb5c15c1b70ce">affine_reccurent_cipher_data_is_valid</a> (const std::string &amp;text, const std::vector&lt; int &gt; &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:a38190e6d22fed7da3c1eb5c15c1b70ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc97eea87b2b555ce53373b91b64b870" id="r_abc97eea87b2b555ce53373b91b64b870"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#abc97eea87b2b555ce53373b91b64b870">simple_replacement_encryption</a> (const std::string &amp;text, const std::string &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:abc97eea87b2b555ce53373b91b64b870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c900a9562e9288a2456a36a831a116" id="r_a29c900a9562e9288a2456a36a831a116"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a29c900a9562e9288a2456a36a831a116">simple_replacement_decryption</a> (const std::string &amp;ciphertext, const std::string &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:a29c900a9562e9288a2456a36a831a116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83838d8695865679f64c762a3efdc46f" id="r_a83838d8695865679f64c762a3efdc46f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a83838d8695865679f64c762a3efdc46f">affine_encryption</a> (const std::string &amp;text, const std::vector&lt; int &gt; &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:a83838d8695865679f64c762a3efdc46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c6d330f66484cb6e260d54a6143c9c" id="r_ac1c6d330f66484cb6e260d54a6143c9c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#ac1c6d330f66484cb6e260d54a6143c9c">affine_decryption</a> (const std::string &amp;ciphertext, const std::vector&lt; int &gt; &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:ac1c6d330f66484cb6e260d54a6143c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12525c2adf17f3ef5b75759885ad3cf2" id="r_a12525c2adf17f3ef5b75759885ad3cf2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a12525c2adf17f3ef5b75759885ad3cf2">affine_reccurent_encryption</a> (const std::string &amp;text, const std::vector&lt; int &gt; &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:a12525c2adf17f3ef5b75759885ad3cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405d45e0f593f24538e1e67b2b84f83e" id="r_a405d45e0f593f24538e1e67b2b84f83e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_affine__ciphers_8cpp.html#a405d45e0f593f24538e1e67b2b84f83e">affine_reccurent_decryption</a> (const std::string &amp;ciphertext, const std::vector&lt; int &gt; &amp;key, const std::string &amp;alphabet)</td></tr>
<tr class="separator:a405d45e0f593f24538e1e67b2b84f83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains affine ciphers encryption and decryption functions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae971d1807a2010eabdb75b3bd393b3e7" name="ae971d1807a2010eabdb75b3bd393b3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae971d1807a2010eabdb75b3bd393b3e7">&#9670;&#160;</a></span>affine_cipher_data_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void affine_cipher_data_is_valid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function checks whether affine cipher data is valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted or decrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is two numbers, using during encryption and decryption </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">input_data_invalid</td><td>if the key and the power of alphabet are not mutual simple or if text contains symbol that not in the alphabet or if one or both of the keys are not digits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c6d330f66484cb6e260d54a6143c9c" name="ac1c6d330f66484cb6e260d54a6143c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c6d330f66484cb6e260d54a6143c9c">&#9670;&#160;</a></span>affine_decryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string affine_decryption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is doing affine decryption of the text. The encryption algorithm is as follows: function accepts text and two numbers, a-key and b-key. After that we are finding values of reversed a-key for every a-key. The remainder of dividing the product of the key a and the inverse key a by the power of the alphabet must be equal to one. After that we find position of every symbol of the text in alphabet, substract b-key from it and multiply it by inverse key a. After that we replace every text symbol with symbol, that is located in the alphabet position, which we found after calculations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is pair of integer numbers inside a vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted text, error message if error occured </dd></dl>

</div>
</div>
<a id="a83838d8695865679f64c762a3efdc46f" name="a83838d8695865679f64c762a3efdc46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83838d8695865679f64c762a3efdc46f">&#9670;&#160;</a></span>affine_encryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string affine_encryption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is doing affine encryption of the text. The encryption algorithm is as follows: function accepts text and two numbers, a-key and b-key. After that we find the position of every text symbol in alphabet, multiply this number by a-key and adding up with b-key. If result is larger then alphabet power we replace result with it's remainder of the division by alphabet power. After that we replace every text symbol with symbol, that is located in the alphabet position, which we found after calculations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is pair of integer numbers inside a vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted text, error message if error occured </dd></dl>

</div>
</div>
<a id="a38190e6d22fed7da3c1eb5c15c1b70ce" name="a38190e6d22fed7da3c1eb5c15c1b70ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38190e6d22fed7da3c1eb5c15c1b70ce">&#9670;&#160;</a></span>affine_reccurent_cipher_data_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void affine_reccurent_cipher_data_is_valid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function checks whether recurrent affine cipher data is valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted or decrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is four numbers, using during encryption and decryption </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">input_data_invalid</td><td>if the key and the power of alphabet are not mutual simple or if text contains symbol that not in the alphabet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405d45e0f593f24538e1e67b2b84f83e" name="a405d45e0f593f24538e1e67b2b84f83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405d45e0f593f24538e1e67b2b84f83e">&#9670;&#160;</a></span>affine_reccurent_decryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string affine_reccurent_decryption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is doing affine recurrent decryption of the text. The decryption algorithm is as follows: function accepts text and four numbers, two a-keys and two b-keys.After that we are making two vectors of keys, which have the same length as the text. In a-keys vector each subsequent key is a product of the previous two. In b-keys vector each subsequent key is the amount of the previous two. After that we are finding values of reversed a-key for every a-key. The remainder of dividing the product of the key a and the inverse key a by the power of the alphabet must be equal to one. After that we find position of every symbol of the text in alphabet, substract b-key in the appropriate vector position from it and multiply it by inverse a-key in the appropriate vector position. After that we replace every text symbol with symbol, that is located in the alphabet position, which we found after calculations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is decrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is two pairs of integer numbers inside a vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted text, error message if error occured </dd></dl>

</div>
</div>
<a id="a12525c2adf17f3ef5b75759885ad3cf2" name="a12525c2adf17f3ef5b75759885ad3cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12525c2adf17f3ef5b75759885ad3cf2">&#9670;&#160;</a></span>affine_reccurent_encryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string affine_reccurent_encryption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is doing recurrent affine encryption of the text. The encryption algorithm is as follows: function accepts text and four numbers, two a-keys and two b-keys. After that we are making two vectors of keys, which have the same length as the text. In a-keys vector each subsequent key is a product of the previous two. In b-keys vector each subsequent key is the amount of the previous two. After that we find the position of every text symbol in alphabet, multiply this number by a-key in the appropriate position and adding up with b-key in the appropriate vector position. If result is larger then alphabet power we replace result with it's remainder of the division by alphabet power. After that we replace every text symbol with symbol, that is located in the alphabet position, which we found after calculations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is two pairs of integer numbers inside a vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted text, error message if error occured </dd></dl>

</div>
</div>
<a id="a416bb0c2856bddb53c89915f9ae5542c" name="a416bb0c2856bddb53c89915f9ae5542c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416bb0c2856bddb53c89915f9ae5542c">&#9670;&#160;</a></span>mutual_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutual_simple </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function checks whether two numbers are mutually prime</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean true if numbers are mutual simple, boolean false if they don't </dd></dl>

</div>
</div>
<a id="a3bb1a3664018850dab00f52655fe3ab0" name="a3bb1a3664018850dab00f52655fe3ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb1a3664018850dab00f52655fe3ab0">&#9670;&#160;</a></span>replacement_cipher_data_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replacement_cipher_data_is_valid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function checks whether replacement cipher data is valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted or decrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is string of mixed alphabet symbols based on the order of which encryption and decryption are taking place</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">input_data_invalid</td><td>if the key and the alphabet have different length or if alphabet contains two similar symbols or if key contains two similar symbols or if key contains symbol that not in the alphabet or if text contains symbol that not in the alphabet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29c900a9562e9288a2456a36a831a116" name="a29c900a9562e9288a2456a36a831a116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c900a9562e9288a2456a36a831a116">&#9670;&#160;</a></span>simple_replacement_decryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string simple_replacement_decryption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is doing simple replacement decryption of the text. The decryption algorithm is as follows: function accepts alphabet and mixed alphabet named key. During encryption we find the position of every text symbol in key and replace every letter with symbol, which is located on the same position in the alphabet</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is decrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is string of mixed alphabet symbols based on the order of which encryption and decryption are taking place</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decrypted text, error message if error occured </dd></dl>

</div>
</div>
<a id="abc97eea87b2b555ce53373b91b64b870" name="abc97eea87b2b555ce53373b91b64b870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc97eea87b2b555ce53373b91b64b870">&#9670;&#160;</a></span>simple_replacement_encryption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string simple_replacement_encryption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function is doing simple replacement encryption of the text. The encryption algorithm is as follows: function accepts alphabet and mixed alphabet named key. During encryption we find the position of every text symbol in alphabet and replace every letter with symbol, which is located on the same position in the key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>is encrypted text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>is string of mixed alphabet symbols based on the order of which encryption and decryption are taking place</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>is string, that contains all symbols, which can be used in input text</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encrypted text, error message if error occured </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
